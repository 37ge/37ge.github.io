# 一.任务控制块

## 1.1. 最小任务控制块结构（将可选的配置部分去掉）

```C/C++
typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking kernel aware debuggers. */
{
    volatile StackType_t * pxTopOfStack; /*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */

    ListItem_t xStateListItem;                  /*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    ListItem_t xEventListItem;                  /*< Used to reference a task from an event list. */
    UBaseType_t uxPriority;                     /*< The priority of the task.  0 is the lowest priority. */
    StackType_t * pxStack;                      /*< Points to the start of the stack. */
    char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
} tskTCB;
```

## 1.2. 任务地址和参数

    从TCB控制块中，我们并未看到保存任务地址和参数。这些其实在创建任务时直接保存到栈上

```C/C++
StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
                                     TaskFunction_t pxCode,
                                     void * pvParameters )
{
    /* Simulate the stack frame as it would be created by a context switch
     * interrupt. */
    pxTopOfStack--;                                                      /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */
    pxTopOfStack--;
    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) prvTaskExitError;                    /* LR */

    pxTopOfStack -= 5;                                                   /* R12, R3, R2 and R1. */
    *pxTopOfStack = ( StackType_t ) pvParameters;                        /* R0 */
    pxTopOfStack -= 8;                                                   /* R11, R10, R9, R8, R7, R6, R5 and R4. */

    return pxTopOfStack;
}
```

## 1.3. 优先级

* 高优先级的任务，优先执行，可以抢占低优先级的任务
* 高优先级的任务不停止，低优先级的任务永远无法执行
* 同等优先级的任务，轮流执行：时间片轮转

## 1.4. 状态

* 运行态：running
* 就绪态：ready
* 阻塞：blocked，等待某件事(时间、事件)
* 暂停：suspend，休息去了

## 1.5. 任务切换顺序

* 找到最高优先级的运行态、就绪态任务，运行它
* 高优先级任务不退出或阻塞，低优先级永远得不到运行。
* 如果大家平级，轮流执行：排队，链表前面的先运行，运行1个tick后乖乖地去链表尾部排队

# 二. 任务态数据结构

    2.1.  所有TCB通过各种链表串联起来

    2.2. freertos有多种链表

```C/C++
static List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; /*< Prioritised ready tasks. */
static List_t xDelayedTaskList1;                         /*< Delayed tasks. */
static List_t xDelayedTaskList2;                         /*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
static List_t * volatile pxDelayedTaskList;              /*< Points to the delayed task list currently being used. */
static List_t * volatile pxOverflowDelayedTaskList;      /*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
static List_t xPendingReadyList;                         /*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
```

**PS：这里就绪态链表是个数组，会把相同优先级的TCB串联起来。这样可以很好的管理优先级，这个很重要很重要**

    例如，我们定义configMAX_PRIORITIES = 4，创建2个优先级为0，一个优先级为2时。链表如下
![list_status](list_status.bmp)

2.3. task中途退让情况

1. 主动退让
2.  被动退让
![break](break.bmp)
